<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Observatorio WebGIS del Café en Costa Rica</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body { margin: 0; }
    #map { height: 100vh; }

    .map-title-top {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95); padding: 8px 14px;
      font: 16px/18px Arial, sans-serif; border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,.25); z-index: 1000; text-align: center; pointer-events: none;
    }
    .map-title-top b { font-weight: 700; display:block; }
    .map-title-top small { display:block; margin-top:2px; font-size:12px; color:#333; }
    .map-subtitle { display:block; margin-top:4px; font-size:12px; color:#555; }

    .legend-combo{
      background:white; padding:8px 10px; font:12px/14px Arial, sans-serif; color:#222;
      border-radius:4px; box-shadow:0 1px 3px rgba(0,0,0,.2);
    }
    .legend-combo .sec-title{ font-weight:700; margin:4px 0 2px; }
    .legend-swatch{ display:inline-block; width:14px; height:10px; margin-right:6px; vertical-align:middle; border:1px solid #fff; }
    .legend-line{ display:inline-block; width:20px; height:0; margin-right:6px; vertical-align:middle; border-top:3px solid #000; }
    .legend-line.dark { border-top-color:#0B3C5D; border-top-width:3.4px; }
    .legend-line.med  { border-top-color:#1E88E5; border-top-width:2.4px; }
    .legend-line.light{ border-top-color:#90CAF9; border-top-width:2px; border-top-style:dashed; }

    .leaflet-bottom.leaflet-right .leaflet-control-scale {
      margin-bottom: 70px; margin-right: 10px; background: rgba(255,255,255,0.9);
      padding: 2px 6px; border-radius: 3px;
    }

    @media print {
      .leaflet-control, .map-title-top { display: none !important; }
      #map { height: 100vh; }
    }
  </style>
</head>
<body>
  <!-- Título + subtítulo dinámico -->
  <div class="map-title-top">
    <b>Observatorio WebGIS del Café en Costa Rica</b>
    <small>Fuentes: SNIT – Nodo ICAFE / Nodo IGN</small>
    <small class="map-subtitle" id="mapSubtitle">Capas activas: 0 · Actualizado: —</small>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Plugin WMTS mínimo -->
  <script>
    L.TileLayer.WMTS = L.TileLayer.extend({
      defaultWmtsParams: { service:'WMTS', request:'GetTile', version:'1.0.0', layer:'', style:'', tilematrixSet:'', format:'image/png' },
      initialize: function (url, options) {
        this._url = url;
        const wmtsParams = L.extend({}, this.defaultWmtsParams);
        for (const i in options) { if (!this.options.hasOwnProperty(i) && i !== 'matrixIds') wmtsParams[i] = options[i]; }
        this.wmtsParams = wmtsParams; L.setOptions(this, options);
      },
      getTileUrl: function (coords) {
        const tm = this.wmtsParams.tilematrixSet + ':' + coords.z, url = this._url;
        return url + L.Util.getParamString(this.wmtsParams, url) + '&tilematrix=' + tm + '&tilerow=' + coords.y + '&tilecol=' + coords.x;
      }
    });
    L.tileLayer.wmts = (url, options) => new L.TileLayer.WMTS(url, options);
  </script>

  <script>
    // ====== MAPA
    const map = L.map("map").setView([9.9, -84.2], 7.5);

    // ====== WMTS SNIT
    const sombra = L.tileLayer.wmts("https://geos1.snitcr.go.cr/ModelosIGN/wmts?", {
      layer:"IGN_MODELO_SOMBRAS_2017", style:"_empty", tilematrixSet:"EPSG:3857", format:"image/png",
      transparent:true, opacity:0.3, attribution:"SNIT - IGN Modelo de Sombras 2017"
    }).addTo(map);

    const mde = L.tileLayer.wmts("https://geos1.snitcr.go.cr/ModelosIGN/wmts?", {
      layer:"IGN_MDE_2017", style:"_empty", tilematrixSet:"EPSG:3857", format:"image/png",
      transparent:true, opacity:0.5, attribution:"SNIT - IGN MDE 2017"
    }).addTo(map);

    // ====== Control de capas
    const layerControl = L.control.layers(
      { "SNIT - Modelo de sombras 2017": sombra, "SNIT - MDE 2017": mde },
      {}, { collapsed: true }
    ).addTo(map);

    // ====== Estado de leyenda y contadores
    let showPointsLegend = false;
    let activeOverlayCount = 0;          // total de overlays vectoriales activos (ríos/puntos/por región)
    let cafeLayerRef = null;
    const regionLayerRefsCafe = {};
    const regionLayerRefsRios = {};

    // Actualizar subtítulo: capas activas + fecha local CR (AAAA-MM-DD)
    function updateSubtitle() {
      const now = new Date();
      // Formato local CR en AAAA-MM-DD
      const y = now.toLocaleString('es-CR', { timeZone: 'America/Costa_Rica', year:'numeric' });
      const m = now.toLocaleString('es-CR', { timeZone: 'America/Costa_Rica', month:'2-digit' });
      const d = now.toLocaleString('es-CR', { timeZone: 'America/Costa_Rica', day:'2-digit' });
      const dateStr = `${y}-${m}-${d}`;
      document.getElementById('mapSubtitle').textContent = `Capas activas: ${activeOverlayCount} · Actualizado: ${dateStr}`;
    }
    updateSubtitle();

    // ====== Leyenda combinada dinámica
    const elevBreaks = [700, 1000, 1300, 1600, 1900];
    const elevColors = ["#7f2704","#d94801","#f16913","#fdd0a2","#f0e6d6","#e6e6e6"];

    const legendCombo = L.control({ position: "bottomright" });
    function buildLegendHTML() {
      let html = "";
      // Ríos (siempre)
      html += `<div class="sec-title">Ríos por Clasificación</div>`;
      html += `<span class="legend-line dark"></span>D01 · Principal<br>`;
      html += `<span class="legend-line med"></span>D02 · Secundario<br>`;
      html += `<span class="legend-line light"></span>D03 · Menor<br>`;

      // Puntos (si hay algún overlay de puntos activo)
      if (showPointsLegend) {
        html += `<div class="sec-title" style="margin-top:6px;">Puntos (elevación, msnm)</div>`;
        const labels = [
          `≤ ${elevBreaks[0]}`,
          `${elevBreaks[0]+1} – ${elevBreaks[1]}`,
          `${elevBreaks[1]+1} – ${elevBreaks[2]}`,
          `${elevBreaks[2]+1} – ${elevBreaks[3]}`,
          `${elevBreaks[3]+1} – ${elevBreaks[4]}`,
          `> ${elevBreaks[4]}`
        ];
        elevColors.forEach((c, i) => {
          html += `<span class="legend-swatch" style="background:${c};"></span>${labels[i]}<br>`;
        });
      }
      return html;
    }
    legendCombo.onAdd = function(){ const d = L.DomUtil.create("div","legend-combo"); d.innerHTML = buildLegendHTML(); return d; };
    legendCombo.addTo(map);
    const refreshLegend = () => { legendCombo.remove(); legendCombo.addTo(map); };

    // ====== Estilos
    function styleRiverByLayer(feature) {
      const cls = (feature.properties.layer || "").toString().toUpperCase();
      if (cls === "D01" || cls === "D1" || cls === "DI") return { color:"#0B3C5D", weight:3.4, opacity:0.98 };
      if (cls === "D02" || cls === "D2") return { color:"#1E88E5", weight:2.4, opacity:0.95 };
      return { color:"#90CAF9", weight:2.0, opacity:0.95, dashArray:"6 4" };
    }
    const getColorByElevation = (e) => {
      if (e == null || isNaN(e)) return "#cccccc";
      if (e <= elevBreaks[0]) return elevColors[0];
      if (e <= elevBreaks[1]) return elevColors[1];
      if (e <= elevBreaks[2]) return elevColors[2];
      if (e <= elevBreaks[3]) return elevColors[3];
      if (e <= elevBreaks[4]) return elevColors[4];
      return elevColors[5];
    };

    // ====== RÍOS (visible por defecto) + RÍOS por REGIÓN (apagados)
    let riosLayerBounds = null;
    let riosMasterRef = null;

    fetch("cafe_rios_4326.geojson")
      .then(r => { if (!r.ok) throw new Error("No se pudo cargar cafe_rios_4326.geojson"); return r.json(); })
      .then(riosData => {
        // Capa maestra visible
        const riosLayer = L.geoJSON(riosData, {
          style: styleRiverByLayer,
          onEachFeature: (f, layer) => {
            const cls = f.properties.layer || "—";
            const reg = f.properties.REGIONAL || "—";
            const canton = f.properties.Cantón || f.properties.Canton || "—";
            const dist = f.properties.Distrito || "—";
            const alt = f.properties.elevacion ?? f.properties.elevation ?? "—";
            const rango = f.properties.rangoaltit || "—";
            const area = f.properties.area_ha ? Number(f.properties.area_ha).toFixed(2) : "—";
            layer.bindPopup(`
              <b>Cauce en zona cafetalera</b><br>
              Clasificación: ${cls}<br>
              Región ICAFE: ${reg}<br>
              Cantón: ${canton}<br>
              Distrito: ${dist}<br>
              Rango altitudinal del café: ${rango}<br>
              Elevación ref.: ${alt} msnm<br>
              Área de café asociada (ha): ${area}
            `);
          }
        }).addTo(map);
        riosMasterRef = riosLayer;
        layerControl.addOverlay(riosLayer, "Ríos en zonas cafetaleras");
        // Contar overlay activo
        activeOverlayCount++; updateSubtitle();

        riosLayerBounds = riosLayer.getBounds();
        if (riosLayerBounds.isValid()) map.fitBounds(riosLayerBounds, { padding:[40,40] });
        else { map.fitBounds([[7.9,-86.6],[11.4,-82.1]]); map.setView([9.8,-84.4], 8.6); }

        // Crear overlays por región (a partir de datos de ríos)
        const regionesRios = Array.from(
          new Set(riosData.features.map(f => (f.properties.REGIONAL || "").trim()).filter(Boolean))
        ).sort();

        regionesRios.forEach(regionNombre => {
          const layerR = L.geoJSON(riosData, {
            filter: f => (f.properties.REGIONAL || "").trim() === regionNombre,
            style: styleRiverByLayer,
            onEachFeature: (f, layer) => {
              const cls = f.properties.layer || "—";
              const canton = f.properties.Cantón || f.properties.Canton || "—";
              const dist = f.properties.Distrito || "—";
              layer.bindPopup(`<b>Río · ${regionNombre}</b><br>Clasificación: ${cls}<br>Cantón: ${canton}<br>Distrito: ${dist}`);
            }
          }); // NO addTo
          regionLayerRefsRios[regionNombre] = layerR;
          layerControl.addOverlay(layerR, `Ríos – Región: ${regionNombre}`);
        });
      })
      .catch(console.warn);

    // ====== PUNTOS CAFÉ (apagados) + por REGIÓN (apagados)
    fetch("cafe_altura_4326.geojson")
      .then(r => r.json())
      .then(data => {
        // Capa general
        const cafeLayer = L.geoJSON(data, {
          pointToLayer: (feature, latlng) => {
            const elev = Number(feature.properties.elevacion ?? feature.properties.elevation ?? NaN);
            return L.circleMarker(latlng, {
              radius: 5, color: "#222", weight: 0.6,
              fillColor: getColorByElevation(elev), fillOpacity: 0.85
            }).bindPopup(`
              <b>Cobertura de café 2017–2018</b><br>
              Región: ${feature.properties.REGIONAL || "—"}<br>
              Cantón: ${feature.properties.Cantón || feature.properties.Canton || "—"}<br>
              Distrito: ${feature.properties.Distrito || "—"}<br>
              Elevación: ${isNaN(elev) ? "—" : `${elev} msnm`}<br>
              Área (ha): ${Number(feature.properties.area_ha || 0).toFixed(2)}
            `);
          }
        }); // no addTo
        cafeLayerRef = cafeLayer;
        layerControl.addOverlay(cafeLayer, "Café 2017–2018 (puntos)");

        // Por región (café)
        const regionesCafe = Array.from(
          new Set(data.features.map(f => (f.properties.REGIONAL || "").trim()).filter(Boolean))
        ).sort();

        regionesCafe.forEach(regionNombre => {
          const regionLayer = L.geoJSON(data, {
            filter: f => (f.properties.REGIONAL || "").trim() === regionNombre,
            pointToLayer: (f, latlng) => {
              const elev = Number(f.properties.elevacion ?? f.properties.elevation ?? NaN);
              return L.circleMarker(latlng, {
                radius: 6, color: "#0b3954", weight: 1,
                fillColor: getColorByElevation(elev), fillOpacity: 0.95
              }).bindPopup(`
                <b>Café · ${regionNombre}</b><br>
                Cantón: ${f.properties.Cantón || f.properties.Canton || "—"}<br>
                Elevación: ${isNaN(elev) ? "—" : `${elev} msnm`}
              `);
            }
          }); // no addTo
          regionLayerRefsCafe[regionNombre] = regionLayer;
          layerControl.addOverlay(regionLayer, `Café – Región: ${regionNombre}`);
        });
      });

    // ====== Eventos: actualizar leyenda/subtítulo y hacer zoom al activar overlays
    function isCafeLayer(l) { return l === cafeLayerRef || Object.values(regionLayerRefsCafe).includes(l); }
    function isRiosLayer(l) { return l === riosMasterRef || Object.values(regionLayerRefsRios).includes(l); }

    map.on("overlayadd", function(e){
      // contar overlays activos
      if (isCafeLayer(e.layer) || isRiosLayer(e.layer)) {
        activeOverlayCount++; updateSubtitle();
      }
      // leyenda: mostrar puntos si se enciende algún overlay de puntos
      if (isCafeLayer(e.layer)) { showPointsLegend = true; refreshLegend(); }
      // zoom al overlay activado
      if (e.layer && e.layer.getBounds) {
        const b = e.layer.getBounds();
        if (b && b.isValid()) map.fitBounds(b, { padding: [40, 40], maxZoom: 10 });
      }
    });

    map.on("overlayremove", function(e){
      if (isCafeLayer(e.layer) || isRiosLayer(e.layer)) {
        activeOverlayCount = Math.max(0, activeOverlayCount - 1);
        updateSubtitle();
      }
      // ocultar sección de puntos si ya no hay ninguno activo
      if (isCafeLayer(e.layer)) {
        const anyPointOn =
          (cafeLayerRef && map.hasLayer(cafeLayerRef)) ||
          Object.values(regionLayerRefsCafe).some(l => map.hasLayer(l));
        if (!anyPointOn) { showPointsLegend = false; refreshLegend(); }
      }
    });

    // ====== Escala
    L.control.scale({ position: "bottomleft", imperial: false, maxWidth: 120 }).addTo(map);
  </script>
</body>
</html>

